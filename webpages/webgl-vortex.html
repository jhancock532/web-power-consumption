<!DOCTYPE html>
<html>
<head>
<title>WebGL Vortex</title>
<style>
body { margin: 0; overflow: hidden; }
canvas { display: block; width: 100%; height: 100%; }
</style>
</head>
<body>
<!-- Code generated by Gemini 2 Flash Experimental -->
<canvas id="glcanvas"></canvas>

<script>
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");

if (!gl) {
  alert("Unable to initialize WebGL. Your browser may not support it.");
}

const vsSource = `
attribute vec4 aVertexPosition;
void main() {
  gl_Position = aVertexPosition;
}
`;
const fsSource = `
precision mediump float;
uniform vec2 uResolution;
uniform vec2 uMouse;
uniform float uTime;

// Corrected Perlin Noise
vec4 permute(vec4 t) {
  return mod(((t*34.0)+1.0)*t, 289.0);
}

float snoise(vec2 v) {
  const vec4 C = vec4(0.1381966011250105,  // (5 - sqrt(5))/20
                      0.276393202250021,  // 2 * C
                      0.045454545454545456, // 1/22
                      0.15606060606060606); // 10/66

  // First corner
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 a  = v - i + dot(i, C.xx);

  // Other corners
  vec2 o = (a.x > a.y)? vec2(1.0,0.0) : vec2(0.0,1.0);
  vec2 b = a - o + C.xx;
  vec2 c = a - 1.0 + C.yy;

  // Hash function
  vec4 h = permute( vec4(i.x, i.y, i.x + 1.0, i.y + 1.0) );

  vec4 lx = mix(h, permute(h + vec4(1.0)), vec4(o.x, o.x, 1.0+o.x, 1.0+o.x));
  vec4 ly = mix(lx, permute(lx + vec4(0.0, 1.0, 0.0, 1.0)), vec4(o.y, o.y, 1.0+o.y, 1.0+o.y));

  vec4 x = mix(ly, permute(ly + 1.0), fract(vec4(a.x, b.x, c.x, a.x)));
  vec4 y = mix(x, permute(x + 1.0), fract(vec4(a.y, b.y, c.y, a.y)));

  // Gradients
  vec4 g = 2.0 * fract(y * C.w) - 1.0;

  // Final noise value
  vec4 m = max(0.5 - vec4(dot(a,a), dot(b,b), dot(c,c), dot(a-1.0,a-1.0)), 0.0);
  m = m*m;
  return 20.0 * dot( m*m, g );
}

void main() {
    vec2 uv = gl_FragCoord.xy / uResolution.xy;
    uv = uv * 2.0 - 1.0;
    uv.x *= uResolution.x / uResolution.y;

    float angle = atan(uv.y, uv.x) + uTime * 0.5 + (uMouse.x / uResolution.x - 0.5) * 2.0;
    float radius = sqrt(dot(uv, uv));

    float vortex = sin(angle * 10.0 - radius * 15.0 + uTime * 2.0) * 0.5 + 0.5;
    float brightness = pow(vortex, 2.0) * (1.0 - radius);

    float noise = snoise(uv * 3.0 + uTime * 0.1);
    vec3 noiseColor = vec3(0.1, 0.0, 0.2) * (noise + 0.5);

    vec3 color = vec3(brightness * (0.5 + sin(uTime * 0.3) * 0.5), 0.0, brightness * (0.5 + cos(uTime * 0.3) * 0.5));
    color += noiseColor;

    gl_FragColor = vec4(color, 1.0);
}
`;

function initShaders() {
  const vertexShader = createShader(gl.VERTEX_SHADER, vsSource);
  const fragmentShader = createShader(gl.FRAGMENT_SHADER, fsSource);

  const shaderProgram = gl.createProgram();
  gl.attachShader(shaderProgram, vertexShader);
  gl.attachShader(shaderProgram, fragmentShader);
  gl.linkProgram(shaderProgram);

  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
    alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
    return null;
  }

  return shaderProgram;
}

function createShader(type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);

  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}
const shaderProgram = initShaders();
gl.useProgram(shaderProgram);
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
const positions = [-1, 1, 1, 1, -1, -1, 1, -1];
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
const positionAttribute = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
gl.enableVertexAttribArray(positionAttribute);
gl.vertexAttribPointer(positionAttribute, 2, gl.FLOAT, false, 0, 0);
const resolutionUniform = gl.getUniformLocation(shaderProgram, "uResolution");
const mouseUniform = gl.getUniformLocation(shaderProgram, "uMouse");
const timeUniform = gl.getUniformLocation(shaderProgram, "uTime");
let mouseX = 0;
let mouseY = 0;
canvas.addEventListener('mousemove', (event) => {
    mouseX = event.clientX;
    mouseY = event.clientY;
});
let startTime = performance.now();
function render() {
    resizeCanvasToDisplaySize(gl.canvas);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.uniform2f(resolutionUniform, gl.canvas.width, gl.canvas.height);
    gl.uniform2f(mouseUniform, mouseX, mouseY);
    gl.uniform1f(timeUniform, (performance.now() - startTime) / 1000);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    requestAnimationFrame(render);
}
function resizeCanvasToDisplaySize(canvas) {
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    if (canvas.width !== width || canvas.height !== height) {
        canvas.width = width;
        canvas.height = height;
    }
}
window.addEventListener('resize', () => {
    resizeCanvasToDisplaySize(gl.canvas);
});
render();
</script>
</body>
</html>